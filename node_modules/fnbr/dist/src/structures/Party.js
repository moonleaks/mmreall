"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const collection_1 = (0, tslib_1.__importDefault)(require("@discordjs/collection"));
const Enums_1 = require("../../enums/Enums");
const Base_1 = (0, tslib_1.__importDefault)(require("../client/Base"));
const PartyAlreadyJoinedError_1 = (0, tslib_1.__importDefault)(require("../exceptions/PartyAlreadyJoinedError"));
const Util_1 = require("../util/Util");
const ClientPartyMember_1 = (0, tslib_1.__importDefault)(require("./ClientPartyMember"));
const PartyMember_1 = (0, tslib_1.__importDefault)(require("./PartyMember"));
const PartyMeta_1 = (0, tslib_1.__importDefault)(require("./PartyMeta"));
/**
 * Represents a party that the client is not a member of
 */
class Party extends Base_1.default {
    /**
     * @param client The main client
     * @param data The party's data
     */
    constructor(client, data) {
        super(client);
        this.id = data.id;
        this.createdAt = new Date(data.created_at);
        this.config = (0, Util_1.makeCamelCase)(data.config);
        this.config.privacy = this.config.joinability === 'OPEN' ? Enums_1.PartyPrivacy.PUBLIC : Enums_1.PartyPrivacy.PRIVATE;
        this.meta = new PartyMeta_1.default(this, data.meta);
        this.revision = data.revision || 0;
        // eslint-disable-next-line arrow-body-style
        this.members = new collection_1.default(data.members.map((m) => {
            var _a;
            if (m.account_id === ((_a = this.client.user) === null || _a === void 0 ? void 0 : _a.id))
                return [m.account_id, new ClientPartyMember_1.default(this, m)];
            return [m.account_id, new PartyMember_1.default(this, m)];
        }));
    }
    /**
     * The party's member count
     */
    get size() {
        return this.members.size;
    }
    /**
     * The party's max member count
     */
    get maxSize() {
        return this.config.maxSize;
    }
    /**
     * The party's leader
     */
    get leader() {
        return this.members.find((m) => m.role === 'CAPTAIN');
    }
    /**
     * The currently selected playlist
     */
    get playlist() {
        return this.meta.playlist;
    }
    /**
     * The custom matchmaking key
     */
    get customMatchmakingKey() {
        return this.meta.customMatchmakingKey;
    }
    /**
     * The squad fill status
     */
    get squadFill() {
        return this.meta.squadFill;
    }
    /**
     * Join this party
     * @throws {PartyAlreadyJoinedError} The client already joined this party
     * @throws {EpicgamesAPIError}
     */
    async join() {
        if (this.members.get(this.client.user.id))
            throw new PartyAlreadyJoinedError_1.default();
        return this.client.joinParty(this.id);
    }
    /**
     * Updates this party's data
     */
    updateData(data) {
        if (data.revision > this.revision)
            this.revision = data.revision;
        this.meta.update(data.party_state_updated, true);
        this.meta.remove(data.party_state_removed);
        this.config.joinability = data.party_privacy_type;
        this.config.maxSize = data.max_number_of_members;
        this.config.subType = data.party_sub_type;
        this.config.type = data.party_type;
        this.config.inviteTtl = data.invite_ttl_seconds;
        this.config.discoverability = data.discoverability;
        let privacy = this.meta.get('Default:PrivacySettings_j');
        privacy = Object.values(Enums_1.PartyPrivacy)
            .find((val) => val.partyType === privacy.PrivacySettings.partyType
            && val.inviteRestriction === privacy.PrivacySettings.partyInviteRestriction
            && val.onlyLeaderFriendsCanJoin === privacy.PrivacySettings.bOnlyLeaderFriendsCanJoin);
        if (privacy)
            this.config.privacy = privacy;
    }
    /**
     * Updates the basic user information (display name and external auths) of all party members
     */
    async updateMemberBasicInfo() {
        const users = await this.client.getProfile(this.members.map((m) => m.id));
        users.forEach((u) => { var _a; return (_a = this.members.get(u.id)) === null || _a === void 0 ? void 0 : _a.update(u); });
    }
    /**
     * Converts this party into an object
     */
    toObject() {
        return {
            id: this.id,
            created_at: this.createdAt.toISOString(),
            config: (0, Util_1.makeSnakeCase)(this.config),
            invites: [],
            members: this.members.map((m) => m.toObject()),
            meta: this.meta.schema,
            revision: 0,
            updated_at: new Date().toISOString(),
        };
    }
}
exports.default = Party;
//# sourceMappingURL=Party.js.map